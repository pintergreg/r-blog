<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>GeoJSON plotting and grid generation in Python</title>
  <meta name="description" content="Plotting GeoJSON with Python">

  <link rel="stylesheet" href="/r-blog/css/main.css">
  <link rel="canonical" href="pintergreg.github.io/r-blog/geojson-plotting-and-grid-generation-in-python">
  <link rel="alternate" type="application/rss+xml" title="My little R knowledgebase" href="pintergreg.github.io/r-blog/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/r-blog/">My little R knowledgebase</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/r-blog/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">GeoJSON plotting and grid generation in Python</h1>
    <p class="post-meta"><time datetime="2016-12-09T15:33:00+01:00" itemprop="datePublished">Dec 9, 2016</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h1 id="plotting-geojson-with-python">Plotting GeoJSON with Python</h1>

<p>After I have became more or less familiar with working with GeoJSON in R, I wanted to do the same in Python. The plotting part seemed very obvious: matplotlib, but the GeoJSON part was the real task.</p>

<p>The first promising sample was http://gis.stackexchange.com/a/93201 but it is too low-level solution for my taste and needs. It reads the GeoJSON as a JSON extracts the coordinates and passes for plotting… The sample uses a <code class="highlighter-rouge">Polygon</code> type, but usually I have MultiPolygon so I had to add other layer of complexity, but I really wanted a one-line solution.</p>

<p>At first I tried to avoid the Plotly and the Leaflet type solutions, those two are great and I might use them eventually, but currently I only wanted the simpliest solution available out there. Then I read about <code class="highlighter-rouge">geopandas</code> here: https://asecuritysite.com/bigdata/geo02 I like <code class="highlighter-rouge">pandas</code> and I almost knew that I found what I was looking for.</p>

<h2 id="plot-a-geojson-file">Plot a GeoJSON file</h2>

<p>The GeoJSON I work with represents the districts of <a href="https://en.wikipedia.org/wiki/Budapest"><code class="highlighter-rouge">Budapest</code></a> taken from <a href="http://www.openstreetmap.org/"><code class="highlighter-rouge">OpenStreetMap</code></a>.
It is really simple: just read the GeoJSON into a GeoPandas GeoDataFrame then plot it!</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="kn">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s">"bp_districts.geojson.json"</span><span class="p">)</span>
<span class="n">plot</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</code></pre>
</div>

<p><img src="output_2_0.png" alt="png" /></p>

<p>To save the figure as a file:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">"output.png"</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="s">'PNG'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s">"output.svg"</span><span class="p">,</span><span class="n">format</span><span class="o">=</span><span class="s">'SVG'</span><span class="p">)</span>
</code></pre>
</div>

<p>It fills the polygons with a set of colors, for setting another color just add arguments to the plot function.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">plot</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s">'white'</span><span class="p">)</span>
</code></pre>
</div>

<p><img src="output_6_0.png" alt="png" /></p>

<h2 id="get-centroids-of-the-districts">Get centroids of the districts</h2>

<p>It is also a simple task with GeoPandas as it uses <a href="http://toblerity.org/shapely/index.html"><code class="highlighter-rouge">Shapely</code></a> for hangling geometries and the <a href="http://toblerity.org/shapely/manual.html#polygons"><code class="highlighter-rouge">Polygon</code></a> objects have a <code class="highlighter-rouge">centroid</code> method that gives back a <a href="http://toblerity.org/shapely/manual.html#points"><code class="highlighter-rouge">Point</code></a> object.</p>

<p>It can be used for the whole <code class="highlighter-rouge">geometry</code> column in the <a href="http://geopandas.org/data_structures.html#geodataframe"><code class="highlighter-rouge">GeoDataFrame</code></a>, that stores geometry as a <a href="http://geopandas.org/data_structures.html#geoseries"><code class="highlighter-rouge">GeoSeries</code></a>. I store the centroids in a new column called <code class="highlighter-rouge">centroid</code>.</p>

<p>Now it just has to be plotted to the same figure as the districts. For this, I used the <a href="http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.scatter"><code class="highlighter-rouge">scatter</code></a> function of <a href="http://matplotlib.org/index.html">Matplotlib</a>. This needs two vector of ordinates. Instead of this, I have a vector od Points, containing the two ordinates. To solve this problem I used a lambda expression found here: https://github.com/geopandas/geopandas/issues/246. With this I could extract the ordinates as vectors.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">centroid_plot</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s">'white'</span><span class="p">)</span>
<span class="n">df</span><span class="p">[</span><span class="s">"centroid"</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">"geometry"</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span>

<span class="c"># print(df["centroid"].apply(lambda p: p.y))</span>
<span class="n">centroid_plot</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s">"centroid"</span><span class="p">]</span><span class="o">.</span><span class="nb">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="n">df</span><span class="p">[</span><span class="s">"centroid"</span><span class="p">]</span><span class="o">.</span><span class="nb">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;matplotlib.collections.PathCollection at 0x7fdd98004898&gt;
</code></pre>
</div>

<p><img src="output_8_1.png" alt="png" /></p>

<h2 id="count-points-over-polygons">Count points over polygons</h2>

<p>First generate some (random) test data into the <code class="highlighter-rouge">points</code> array. For a floating point ranged random ceneration the <a href="https://docs.python.org/3/library/random.html#random.uniform"><code class="highlighter-rouge">random.uniform</code></a> method can be used. For the bounds I used a louse surrounding square of Budapest and generated 500 points like this. Now, I stored the coordinates in tuples, so I also needed a trick to plot them with the <code class="highlighter-rouge">scatter</code> method. This time I got help from here: http://stackoverflow.com/a/17478866/4737417.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">random</span>

<span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">500</span><span class="p">):</span>
    <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">18.93</span><span class="p">,</span><span class="mf">19.3375</span><span class="p">),</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">47.35</span><span class="p">,</span><span class="mf">47.62</span><span class="p">)))</span>

<span class="n">plot</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s">'white'</span><span class="p">)</span>
<span class="c"># with some help from http://stackoverflow.com/a/17478866/4737417</span>
<span class="n">plot</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="o">*</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">points</span><span class="p">))</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;matplotlib.collections.PathCollection at 0x7fdd9a24bac8&gt;
</code></pre>
</div>

<p><img src="output_10_1.png" alt="png" /></p>

<p>The next step is counting the points by the districts. If a point is outside any of the districts the left ‘uncounted’.</p>

<p>How to determine whether a point is over a district (polygon)? The Shapely package has an easy solution for this: the <a href="http://toblerity.org/shapely/shapely.geometry.html#shapely.geometry.base.BaseGeometry.intersects"><code class="highlighter-rouge">intersects</code></a> method.</p>

<p>A simple example to test it to create some points (<code class="highlighter-rouge">p1</code>, <code class="highlighter-rouge">p2</code>, <code class="highlighter-rouge">p3</code>) and a polygon (<code class="highlighter-rouge">poly</code>) then test all the three points based on this post: http://stackoverflow.com/a/30440386/4737417.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">p1</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">)</span>
<span class="n">p2</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">p3</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="n">poly</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>

<span class="c"># with some help from http://stackoverflow.com/a/30440386/4737417</span>
<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">]:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>    

<span class="c"># for i in range(23):    </span>
<span class="c">#     print(df['geometry'][i].intersects(df["centroid"][i]))</span>
</code></pre>
</div>

<h3 id="count-points-over-the-districts">Count points over the districts</h3>

<p>I do the counting “manually” in the following example. I create an empty <a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries">dictionary</a> for the counting. I use district identifiers (<code class="highlighter-rouge">did</code>), that was added by me to the GeoJSON as keys and the values will be the counts, that are set to zero for starting.</p>

<p>Iterating over the districts and the points. If a point intersects with the district (polygon) I increase the counter by one. After that the dictionary is converted to a Pandas DataFrame and “reindexed” (reseted its index).</p>

<p>The newly created <code class="highlighter-rouge">counts_df</code> DataFrame can be easily merged into the GeoDataFrame containing the district geometries by the <code class="highlighter-rouge">did</code> column with the <code class="highlighter-rouge">merge</code> method of the GeoDataFrame as shown in http://geopandas.org/mergingdata.html.
Note that, the GeoDataFrame has to be on the left and the DataFrame on the right, otherwise the resulting object will be DataFrame ainstead of GeoDataFrame!</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>

<span class="n">counts</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
    <span class="n">counts</span><span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">did</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">row</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="n">p</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">row</span><span class="o">.</span><span class="n">did</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
                <span class="n">counts</span><span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">did</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">counts</span><span class="p">[</span><span class="n">row</span><span class="o">.</span><span class="n">did</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">counts_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s">"index"</span><span class="p">)</span>

<span class="n">counts_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c">#http://stackoverflow.com/a/11346337/4737417</span>
<span class="n">counts_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s">'did'</span><span class="p">,</span> <span class="s">'count'</span><span class="p">]</span>

<span class="c"># based on http://geopandas.org/mergingdata.html</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">counts_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s">'did'</span><span class="p">)</span>
</code></pre>
</div>

<h2 id="choropleth">Choropleth</h2>

<p>Taken from the <a href="https://en.wikipedia.org/wiki/Choropleth_map">Wikipedia</a>, a “choropleth map is a thematic map in which areas are shaded or patterned in proportion to the measurement of the statistical variable being displayed on the map”.</p>

<p>Use the previously counted points per district to color the city according to the count of points (based on https://ocefpaf.github.io/python4oceanographers/blog/2015/08/24/choropleth/). The yellow-green color scheme is used in the example below and the alpha is set it 1 (default is 0.5).</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">df</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">column</span><span class="o">=</span><span class="s">'count'</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s">"YlGn"</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
</code></pre>
</div>

<p><img src="output_16_0.png" alt="png" /></p>

<h2 id="generate-grid">Generate grid</h2>

<p>Next, I want to generate a 500 meters × 500 meters grid over Budapest. To generate a grid on ots own is not too complicated, but the geometry, the polygons and the points of the city is in a degree based geodetic coordinate system called World Geodetic System 1984, shortly WSG84, that is used in GPS. It is also called <a href="https://epsg.io/4326">EPSG:4326</a>.</p>

<p>In this coordinate system is not really possible to use meter as unit. Of course it can be approximated, hence 0.01 (0° 00′ 36″) is about 1.1132 km at the equator, <em>but</em> the problem is only true at the equator. Farther on it is less and less. More about this <a href="https://en.wikipedia.org/wiki/Decimal_degrees">in the Wiki</a>.</p>

<p>So, I have to reproject the original coordination system (ESPG:4326) to a proper one with metric unit. Finding the proper one is not necessarily easy. There are many topographic mappings with different scales and for different areas. E.g. for a city, for a country or for a slice of the globe. The smaller the scale of the mappings, the more precise the mapping should be.</p>

<p>There is a projection containing Hungary called <a href="http://spatialreference.org/ref/epsg/hd72-eov/">EPSG:23700</a>, that seems to be acceptable hence Hungary is not so big.</p>

<p>(<a href="http://spatialreference.org/ref/epsg/23034/">EPSG:23034</a> also covers the most of the country, but it is much larger and might not be so precise, even as <a href="http://www.spatialreference.org/ref/epsg/4258/">EPSG:4258</a> that has a scope of Europe.)</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">#http://gis.stackexchange.com/questions/54119/creating-square-grid-polygon-shapefile-with-python</span>
<span class="kn">import</span> <span class="nn">shapefile</span> <span class="kn">as</span> <span class="nn">shp</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="c"># minx,maxx,miny,maxy = xxxxx, xxxxx, xxxxx, xxxxx (specify the extents)</span>
<span class="c"># dx = xx (size of grid)</span>
<span class="c"># dy = xx (size of grid)</span>
<span class="n">minx</span><span class="p">,</span><span class="n">maxx</span><span class="p">,</span><span class="n">miny</span><span class="p">,</span><span class="n">maxy</span> <span class="o">=</span> <span class="mf">18.93</span><span class="p">,</span> <span class="mf">19.3375</span><span class="p">,</span> <span class="mf">47.35</span><span class="p">,</span> <span class="mf">47.62</span>
<span class="n">dx</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">dy</span> <span class="o">=</span> <span class="mi">1000</span>

<span class="n">nx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">maxx</span> <span class="o">-</span> <span class="n">minx</span><span class="p">)</span><span class="o">/</span><span class="n">dx</span><span class="p">))</span>
<span class="n">ny</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">maxy</span> <span class="o">-</span> <span class="n">miny</span><span class="p">)</span><span class="o">/</span><span class="n">dy</span><span class="p">))</span>

<span class="n">w</span> <span class="o">=</span> <span class="n">shp</span><span class="o">.</span><span class="n">Writer</span><span class="p">(</span><span class="n">shp</span><span class="o">.</span><span class="n">POLYGON</span><span class="p">)</span>
<span class="n">w</span><span class="o">.</span><span class="n">autoBalance</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">w</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="s">"ID"</span><span class="p">)</span>
<span class="nb">id</span><span class="o">=</span><span class="mi">0</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
        <span class="nb">id</span><span class="o">+=</span><span class="mi">1</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="n">minx</span><span class="o">+</span><span class="n">dx</span><span class="o">*</span><span class="n">j</span><span class="p">,</span><span class="n">maxx</span><span class="p">),</span><span class="nb">max</span><span class="p">(</span><span class="n">maxy</span><span class="o">-</span><span class="n">dy</span><span class="o">*</span><span class="n">i</span><span class="p">,</span><span class="n">miny</span><span class="p">)])</span>
        <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="n">minx</span><span class="o">+</span><span class="n">dx</span><span class="o">*</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">maxx</span><span class="p">),</span><span class="nb">max</span><span class="p">(</span><span class="n">maxy</span><span class="o">-</span><span class="n">dy</span><span class="o">*</span><span class="n">i</span><span class="p">,</span><span class="n">miny</span><span class="p">)])</span>
        <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="n">minx</span><span class="o">+</span><span class="n">dx</span><span class="o">*</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">maxx</span><span class="p">),</span><span class="nb">max</span><span class="p">(</span><span class="n">maxy</span><span class="o">-</span> <span class="n">dy</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">miny</span><span class="p">)])</span>
        <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="n">minx</span><span class="o">+</span><span class="n">dx</span><span class="o">*</span><span class="n">j</span><span class="p">,</span><span class="n">maxx</span><span class="p">),</span><span class="nb">max</span><span class="p">(</span><span class="n">maxy</span><span class="o">-</span><span class="n">dy</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">miny</span><span class="p">)])</span>
        <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">w</span><span class="o">.</span><span class="n">poly</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>
        <span class="n">w</span><span class="o">.</span><span class="n">record</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>

<span class="c"># w.save('polygon_grid')</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;class 'int'&gt;
</code></pre>
</div>

<h3 id="projections-in-geopandas">Projections in Geopandas</h3>

<p>Managing projections in Geopandas is easy, the <code class="highlighter-rouge">to_crs</code> function solves this (CRS means Coordinate Reference System), read more <a href="http://geopandas.org/projections.html">Managing Projections</a>.</p>

<p>See below the EPSG:4326 and the EPSG:23700 “version” of Budapest.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">df</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_crs</span><span class="p">({</span><span class="s">'init'</span><span class="p">:</span> <span class="s">'epsg:23700'</span><span class="p">})</span>
<span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="err">'init':</span><span class="w"> </span><span class="err">'epsg:4326'</span><span class="p">}</span><span class="w">
</span><span class="p">{</span><span class="err">'init':</span><span class="w"> </span><span class="err">'epsg:23700'</span><span class="p">}</span><span class="w">





</span><span class="err">&lt;matplotlib.axes._subplots.AxesSubplot</span><span class="w"> </span><span class="err">at</span><span class="w"> </span><span class="mi">0</span><span class="err">x</span><span class="mi">7</span><span class="err">fddac</span><span class="mi">9357</span><span class="err">b</span><span class="mi">8</span><span class="err">&gt;</span><span class="w">
</span></code></pre>
</div>

<p><img src="output_20_2.png" alt="png" /></p>

<p><img src="output_20_3.png" alt="png" /></p>

<h3 id="bounding-box">Bounding box</h3>

<p>For generating the grid exactly to Budapest, the bounding box of the multipolygon has to be determined before. One of its corner can be the starting point for the grid generation. Geopandas provides many useful functions via Shapely for this purpose.</p>

<ol>
  <li><code class="highlighter-rouge">boundary</code> to get the border of a polygon</li>
  <li><code class="highlighter-rouge">convex_hull</code> to get convex polygon that surround a polygony</li>
  <li><code class="highlighter-rouge">envelope</code> to get a bounding square of a polygon</li>
</ol>

<p>The results of these three is plotted below in this order. It can be seen that they works on every polygon, hence I have a multipolygon. These have to be merged first to get a bounding square of the whole city. To achieve this the <a href="http://toblerity.org/shapely/manual.html#shapely.ops.cascaded_union"><code class="highlighter-rouge">cascaded_union</code></a> is used. It is well-explained <a href="http://stackoverflow.com/a/40386377/4737417">here</a>.</p>

<p>Now, the <code class="highlighter-rouge">envelope</code> function can be used on the merged polygon.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">df</span><span class="o">.</span><span class="n">boundary</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">df</span><span class="o">.</span><span class="n">convex_hull</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">df</span><span class="o">.</span><span class="n">envelope</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>

<span class="c"># based on http://stackoverflow.com/a/40386377/4737417</span>
<span class="kn">from</span> <span class="nn">shapely.ops</span> <span class="kn">import</span> <span class="n">cascaded_union</span>
<span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">(</span><span class="n">cascaded_union</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">geometry</span><span class="p">))</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">(</span><span class="n">cascaded_union</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">geometry</span><span class="p">))</span><span class="o">.</span><span class="n">envelope</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7fddae408470&gt;
</code></pre>
</div>

<p><img src="output_22_1.png" alt="png" /></p>

<p><img src="output_22_2.png" alt="png" /></p>

<p><img src="output_22_3.png" alt="png" /></p>

<p><img src="output_22_4.png" alt="png" /></p>

<p><img src="output_22_5.png" alt="png" /></p>

<h3 id="the-actual-grid-generation">The actual grid generation</h3>

<p>I generate the grid “manually” with two loops to calculate the points of every cell, and create a polygon of these points. The polygons are stored in an array then converted to a GeoSeries (which is returned by the function).</p>

<p>N.B.: The given value for the grid range still not from the formerly calculated city coundaries, and 1000 × 1000 meter grid is generated in the example below.</p>

<p>After the grid was generated, the initial CRS was set to ESPG:23700, hence the coordinates was taken fro that coordination system, after that it was re-projected to ESPG:4326 (WSG84).</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">geopandas</span> <span class="kn">import</span> <span class="n">GeoSeries</span>

<span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">):</span>
<span class="c"># for x, y in zip(range(minx, maxx+1, dx), range(miny, maxy+1, dy)):</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">dx</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">miny</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">dy</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),(</span><span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">dy</span><span class="p">)]</span>
            <span class="n">mp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polygon</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">GeoSeries</span><span class="p">(</span><span class="n">mp</span><span class="p">)</span>

<span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="p">(</span><span class="mi">640000</span><span class="p">,</span><span class="mi">220000</span><span class="p">,</span><span class="mi">675000</span><span class="p">,</span><span class="mi">255000</span><span class="p">,</span><span class="mi">1000</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">grid</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="p">{</span><span class="s">'init'</span> <span class="p">:</span><span class="s">'epsg:23700'</span><span class="p">}</span>
<span class="k">print</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
<span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">to_crs</span><span class="p">({</span><span class="s">'init'</span><span class="p">:</span> <span class="s">'epsg:4326'</span><span class="p">})</span>
<span class="k">print</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

<span class="n">grid</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="err">'init':</span><span class="w"> </span><span class="err">'epsg:23700'</span><span class="p">}</span><span class="w">
</span><span class="p">{</span><span class="err">'init':</span><span class="w"> </span><span class="err">'epsg:4326'</span><span class="p">}</span><span class="w">





</span><span class="err">&lt;matplotlib.axes._subplots.AxesSubplot</span><span class="w"> </span><span class="err">at</span><span class="w"> </span><span class="mi">0</span><span class="err">x</span><span class="mi">7</span><span class="err">fdd</span><span class="mi">91</span><span class="err">a</span><span class="mi">64</span><span class="err">e</span><span class="mi">80</span><span class="err">&gt;</span><span class="w">
</span></code></pre>
</div>

<p><img src="output_24_2.png" alt="png" /></p>

<h2 id="eliminating-the-unneeded-cells-from-the-grid">Eliminating the unneeded cells from the grid</h2>

<p>The grid is generated over the bounding square, so there are cells that covers place outside the city. These are not required and will be dropped. For this it has to be decide which ones are outside the city. Fortunately, this is analoguous to the point intersection.</p>

<h3 id="polygon-intersection">Polygon intersection</h3>

<p>Here is an example for polygon intersection based on this: ttp://geopandas.org/set_operations.html. For polygon is created and only for plotting converted to GeoSeries. The results of the intersection checks are printed out. <code class="highlighter-rouge">p1</code> is the big polygon and its intersects with <code class="highlighter-rouge">p2</code> and <code class="highlighter-rouge">p4</code> (which half is inside, half is outside), but not intersects with <code class="highlighter-rouge">p3</code>. <code class="highlighter-rouge">p4</code> also intersects with <code class="highlighter-rouge">p3</code>, hence has a common point (5,2).</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">p1</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">)])</span>
<span class="n">p2</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
<span class="n">p3</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">([(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
<span class="n">p4</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">([(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>

<span class="n">GeoSeries</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">p3</span><span class="p">,</span><span class="n">p4</span><span class="p">])</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">p2</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">p3</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">p4</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">p4</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">p3</span><span class="p">))</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>True
False
True
True
</code></pre>
</div>

<p><img src="output_26_1.png" alt="png" /></p>

<p>Droping out a polygon from a GeoSeries is simple by its index. When big polygon (<code class="highlighter-rouge">p1</code>) is dropped the result can be seen below.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">GeoSeries</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">p3</span><span class="p">,</span><span class="n">p4</span><span class="p">])</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7fdd91a8e400&gt;
</code></pre>
</div>

<p><img src="output_28_1.png" alt="png" /></p>

<p>The merged multipolygon of Budapest is stored in the <code class="highlighter-rouge">whole_bp</code> variable and used for eliminating the unrequired cells from the grid.</p>

<p>Iterating over <code class="highlighter-rouge">grid</code> (which is a GeoSeries) and check every cell whether it intersects the city (<code class="highlighter-rouge">whole_bp</code>). For some reason the <code class="highlighter-rouge">intersects</code> function gives back a Series of two object and the logical value is stored in the second one, so it is extracted by the <code class="highlighter-rouge">iloc(1)[0]</code> expression.</p>

<p>The indexes of the cells to be dropped are gatheres into an array <code class="highlighter-rouge">to_drop</code> and later iterating over this array and for every element a <code class="highlighter-rouge">drop</code> function is called for the indexes. The <code class="highlighter-rouge">inplace=True</code> results that the dropping operation is executed on the GeoSeries that is called upon. Note that I copied the original <code class="highlighter-rouge">grid</code> object to a <code class="highlighter-rouge">grid_cleared</code> and worked on that one.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">bp_whole</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">(</span><span class="n">cascaded_union</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">geometry</span><span class="p">))</span>

<span class="c"># grid = gpd.GeoDataFrame({'geometry': g, 'df1':list(range(0,len(g)))})</span>
<span class="c"># # print(grid)</span>
<span class="c"># from geopandas.tools import overlay</span>
<span class="c"># newdf = overlay(grid, bp_whole, how="intersection")</span>
<span class="c"># newdf.plot()</span>
<span class="c"># print(g)</span>
<span class="n">to_drop</span><span class="o">=</span><span class="p">[]</span>
<span class="k">for</span> <span class="n">index</span><span class="p">,</span><span class="n">cell</span> <span class="ow">in</span> <span class="n">grid</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">bp_whole</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span><span class="c"># for some reason it returns a series</span>
        <span class="n">to_drop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

<span class="n">grid_cleared</span> <span class="o">=</span> <span class="n">grid</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">to_drop</span><span class="p">:</span>
    <span class="n">grid_cleared</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">grid_cleared</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7fdd9197e198&gt;
</code></pre>
</div>

<p><img src="output_30_1.png" alt="png" /></p>

<h2 id="save-as-geojson">Save as GeoJSON</h2>

<p>Finally save the the grid to a GeoJSON file. As the GeoDataFrame has a <code class="highlighter-rouge">to_json</code> method, that returns the GeoJSON as a string, first I created a GeoDataFrame from the GeoSeries. This basically means that I put the GeoSeries into a column named <code class="highlighter-rouge">geometry</code>. Additionally I also added a column with an ID.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">grid_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span><span class="s">'geometry'</span><span class="p">:</span> <span class="n">g2</span><span class="p">,</span> <span class="s">'id'</span><span class="p">:</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">g2</span><span class="p">)))})</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"my_own_grid_1000.geo.json"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">grid_gdf</span><span class="o">.</span><span class="n">to_json</span><span class="p">(),</span> <span class="nb">file</span><span class="o">=</span><span class="nb">file</span><span class="p">)</span>
</code></pre>
</div>

<h2 id="some-link-that-not-listed-as-source-but-potentially-can-be-useful">Some link that not listed as source, but potentially can be useful</h2>

<ul>
  <li><a href="http://www.data-analysis-in-python.org/t_gis.html">GIS in Python</a></li>
  <li><a href="https://pythongisresources.wordpress.com/packages/">Python GIS Resources - packages</a></li>
  <li>http://geojson.io</li>
  <li>
    <p><a href="http://geojsonlint.com/">GeoJSON validator</a></p>
  </li>
  <li><a href="https://pcjericks.github.io/py-gdalogr-cookbook/vector_layers.html">Python GDAL/ODR examples</a></li>
  <li><a href="http://matplotlib.org/basemap/users/examples.html">Plotting data on a map (Example Gallery)</a></li>
  <li>https://github.com/mlaloux/My-Python-GIS_StackExchange-answers/blob/master/Generate%20grid%20programmatically%20using%20QGIS%20from%20Python.md
    <ul>
      <li><code class="highlighter-rouge">processing</code> package is necessary for this, but for some reason it have not isntalled wit pip</li>
      <li>can create hexagonal grid as well</li>
    </ul>
  </li>
  <li>Post about working with GeoPandas
    <ul>
      <li>https://borealperspectives.wordpress.com/2016/03/07/plotting-polygon-shapefiles-on-a-matplotlib-basemap-with-geopandas-shapely-and-descartes/
        <ul>
          <li>very nice map plotting</li>
        </ul>
      </li>
      <li><a href="https://gist.github.com/jorisvandenbossche/7b30ed43366a85af8626">GeoPandas - the perfect marriage between shapefiles and dataframes</a></li>
      <li><a href="https://github.com/urschrei/Geopython/blob/master/README.md">Geocomputation, Cartography, and Spatial Analysis Techniques Using Python</a></li>
      <li><a href="https://michelleful.github.io/code-blog/2015/04/29/geopandas-manipulation/">Blogpost “Geodata manipulation with GeoPandas” by Michelle Fullwood</a></li>
    </ul>
  </li>
  <li><a href="https://karta.fortyninemaps.com/">Karta - Python toolkit for geospatial analysis</a></li>
  <li><a href="http://lenguyenthedat.com/drawing-maps-python/">geopandas and mpleaflet</a></li>
  <li><a href="https://peteris.rocks/blog/openstreetmap-city-blocks-as-geojson-polygons/">OpenStreetMap city blocks as GeoJSON polygons</a></li>
  <li>
    <p><a href="http://wrobstory.github.io/2013/04/python-maps-choropleth.html">Creating Map Visualizations in &lt;10 lines of Python</a></p>
  </li>
  <li><a href="http://gis.stackexchange.com/questions/87152/how-to-reproject-wgs84-to-a-metric-coordinate-system-with-own-reference-point-in">Create own CRS with QGIS</a></li>
  <li><a href="http://gis.stackexchange.com/a/114577">On the fly re-project in QGIS</a></li>
  <li>
    <p><a href="https://github.com/OSGeoLabBp/eov2etrs/">Transformation between Hungarian EOV and ETRS89 based on proj4 grids</a></p>
  </li>
  <li>
    <p><a href="http://mathstat.slu.edu/escher/index.php/Tessellations_by_Squares,_Rectangles_and_other_Polygons">Mathematical summary about tessellations</a></p>
  </li>
  <li>
    <p><a href="https://www.gaia-gis.it/fossil/libspatialite/wiki?name=tesselations-4.0">Tesselations with spatialite</a></p>
  </li>
  <li>GIS reated Python packages
    <ul>
      <li>https://pypi.python.org/pypi/descartes/0.1</li>
      <li>https://pypi.python.org/pypi/pyproj</li>
      <li>https://pypi.python.org/pypi/spacegrids/</li>
      <li>https://pypi.python.org/pypi/geopy/1.11.0</li>
      <li>https://pypi.python.org/pypi/Gryd/1.1.0</li>
    </ul>
  </li>
  <li><a href="http://darribas.org/gds15/">Geographic Data Science - online stuff, slides and more</a></li>
</ul>

<h3 id="more-links-without-categorization---todo">More links without categorization - TODO</h3>

<ul>
  <li>http://gis.stackexchange.com/questions/97462/creating-grid-polygons-from-coordinates-using-r-or-python</li>
  <li>https://grass.osgeo.org/grass70/manuals/v.mkgrid.html</li>
</ul>

<p>https://github.com/GeospatialPython/pyshp</p>

<p>http://kiwi.atmos.colostate.edu/BUGS/geodesic/interpolate.html
http://scitools.org.uk/cartopy/docs/v0.13/matplotlib/gridliner.html
http://scitools.org.uk/cartopy/docs/v0.13/matplotlib/advanced_plotting.html
https://ocefpaf.github.io/python4oceanographers/blog/2015/02/02/cartopy_folium_shapefile/</p>

<p>http://stackoverflow.com/questions/36231289/sum-the-total-line-length-inside-grid-using-python
http://gis.stackexchange.com/questions/139739/how-to-merge-polygons-using-geodataframe</p>

<p>http://stackoverflow.com/questions/39630501/spatial-index-to-find-points-within-polygon-if-points-and-polygon-have-same-min</p>

<p>rasterio/pyshp
http://gis.stackexchange.com/questions/209785/creating-numpy-array-with-grid-cell-area-in-gdal-rasterio/209942
http://gis.stackexchange.com/questions/54119/creating-square-grid-polygon-shapefile-with-python
https://github.com/GeospatialPython/pyshp</p>

<p>.loadshp bp districts CP1252 23032
23034 budapest http://spatialreference.org/ref/epsg/23034/
SELECT asgeojson (ST_SquareGrid(geometry, 1000)) FROM budapest;
http://morphocode.com/using-ogr2ogr-convert-data-formats-geojson-postgis-esri-geodatabase-shapefiles/</p>

<p>ST_Transform( geom Geometry , newSRID Integer ) : Geometry
http://stackoverflow.com/a/12205530/4737417 projekció átváltásról és távolságszámításról</p>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">My little R knowledgebase</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>My little R knowledgebase</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/pintergreg"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">pintergreg</span></a>

          </li>
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>My "Today I Learned" posts mainly about R.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
